"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require("./");
const tmpl = require("riot-tmpl");
tmpl.brackets.set('{{ }}');
tmpl.tmpl.errorHandler = () => { };
class Workflow {
    constructor(id, nodes, connections, active, nodeTypes, staticData, settings) {
        this.nodes = {};
        this.id = id;
        this.nodeTypes = nodeTypes;
        let nodeType;
        for (const node of nodes) {
            this.nodes[node.name] = node;
            nodeType = this.nodeTypes.getByName(node.type);
            if (nodeType === undefined) {
                continue;
            }
            const nodeParameters = _1.NodeHelpers.getNodeParameters(nodeType.description.properties, node.parameters, true, false);
            node.parameters = nodeParameters !== null ? nodeParameters : {};
        }
        this.connectionsBySourceNode = connections;
        this.connectionsByDestinationNode = this.__getConnectionsByDestination(connections);
        this.active = active || false;
        this.staticData = _1.ObservableObject.create(staticData || {}, undefined, { ignoreEmptyOnFirstChild: true });
        this.settings = settings || {};
    }
    __getConnectionsByDestination(connections) {
        const returnConnection = {};
        let connectionInfo;
        let maxIndex;
        for (const sourceNode in connections) {
            if (!connections.hasOwnProperty(sourceNode)) {
                continue;
            }
            for (const type in connections[sourceNode]) {
                if (!connections[sourceNode].hasOwnProperty(type)) {
                    continue;
                }
                for (const inputIndex in connections[sourceNode][type]) {
                    if (!connections[sourceNode][type].hasOwnProperty(inputIndex)) {
                        continue;
                    }
                    for (connectionInfo of connections[sourceNode][type][inputIndex]) {
                        if (!returnConnection.hasOwnProperty(connectionInfo.node)) {
                            returnConnection[connectionInfo.node] = {};
                        }
                        if (!returnConnection[connectionInfo.node].hasOwnProperty(connectionInfo.type)) {
                            returnConnection[connectionInfo.node][connectionInfo.type] = [];
                        }
                        maxIndex = returnConnection[connectionInfo.node][connectionInfo.type].length - 1;
                        for (let j = maxIndex; j < connectionInfo.index; j++) {
                            returnConnection[connectionInfo.node][connectionInfo.type].push([]);
                        }
                        returnConnection[connectionInfo.node][connectionInfo.type][connectionInfo.index].push({
                            node: sourceNode,
                            type,
                            index: parseInt(inputIndex, 10)
                        });
                    }
                }
            }
        }
        return returnConnection;
    }
    convertObjectValueToString(value) {
        return `[Object: ${JSON.stringify(value)}]`;
    }
    checkIfWorkflowCanBeActivated(ignoreNodeTypes) {
        let node;
        let nodeType;
        for (const nodeName of Object.keys(this.nodes)) {
            node = this.nodes[nodeName];
            if (node.disabled === true) {
                continue;
            }
            if (ignoreNodeTypes !== undefined && ignoreNodeTypes.includes(node.type)) {
                continue;
            }
            nodeType = this.nodeTypes.getByName(node.type);
            if (nodeType === undefined) {
                continue;
            }
            if (nodeType.trigger !== undefined || nodeType.webhook !== undefined) {
                return true;
            }
        }
        return false;
    }
    checkReadyForExecution() {
        let node;
        let nodeType;
        let nodeIssues = null;
        const workflowIssues = {};
        for (const nodeName of Object.keys(this.nodes)) {
            nodeIssues = null;
            node = this.nodes[nodeName];
            if (node.disabled === true) {
                continue;
            }
            nodeType = this.nodeTypes.getByName(node.type);
            if (nodeType === undefined) {
                nodeIssues = {
                    typeUnknown: true,
                };
            }
            else {
                nodeIssues = _1.NodeHelpers.getNodeParametersIssues(nodeType.description.properties, node);
            }
            if (nodeIssues !== null) {
                workflowIssues[node.name] = nodeIssues;
            }
        }
        if (Object.keys(workflowIssues).length === 0) {
            return null;
        }
        return workflowIssues;
    }
    getStaticData(type, node) {
        let key;
        if (type === 'global') {
            key = 'global';
        }
        else if (type === 'node') {
            if (node === undefined) {
                throw new Error(`The request data of context type "node" the node parameter has to be set!`);
            }
            key = `node:${node.name}`;
        }
        else {
            throw new Error(`The context type "${type}" is not know. Only "global" and node" are supported!`);
        }
        if (this.staticData[key] === undefined) {
            this.staticData[key] = _1.ObservableObject.create({}, this.staticData);
        }
        return this.staticData[key];
    }
    getTriggerNodes() {
        const returnNodes = [];
        let node;
        let nodeType;
        for (const nodeName of Object.keys(this.nodes)) {
            node = this.nodes[nodeName];
            if (node.disabled === true) {
                continue;
            }
            nodeType = this.nodeTypes.getByName(node.type);
            if (nodeType !== undefined && nodeType.trigger) {
                returnNodes.push(node);
            }
        }
        return returnNodes;
    }
    getNode(nodeName) {
        if (this.nodes.hasOwnProperty(nodeName)) {
            return this.nodes[nodeName];
        }
        return null;
    }
    renameNodeInExpressions(parameterValue, currentName, newName) {
        if (typeof parameterValue !== 'object') {
            if (typeof parameterValue === 'string' && parameterValue.charAt(0) === '=') {
                if (parameterValue.includes(currentName)) {
                    const currentNameEscaped = currentName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    parameterValue = parameterValue.replace(new RegExp(`(\\$node(\.|\\["|\\[\'))${currentNameEscaped}((\.|"\\]|\'\\]))`, 'g'), `$1${newName}$3`);
                }
            }
            return parameterValue;
        }
        if (Array.isArray(parameterValue)) {
            const returnArray = [];
            for (const currentValue of parameterValue) {
                returnArray.push(this.renameNodeInExpressions(currentValue, currentName, newName));
            }
            return returnArray;
        }
        const returnData = {};
        for (const parameterName of Object.keys(parameterValue)) {
            returnData[parameterName] = this.renameNodeInExpressions(parameterValue[parameterName], currentName, newName);
        }
        return returnData;
    }
    renameNode(currentName, newName) {
        if (this.nodes[currentName] !== undefined) {
            this.nodes[newName] = this.nodes[currentName];
            this.nodes[newName].name = newName;
            delete this.nodes[currentName];
        }
        for (const node of Object.values(this.nodes)) {
            node.parameters = this.renameNodeInExpressions(node.parameters, currentName, newName);
        }
        if (this.connectionsBySourceNode.hasOwnProperty(currentName)) {
            this.connectionsBySourceNode[newName] = this.connectionsBySourceNode[currentName];
            delete this.connectionsBySourceNode[currentName];
        }
        let sourceNode, type, sourceIndex, connectionIndex, connectionData;
        for (sourceNode of Object.keys(this.connectionsBySourceNode)) {
            for (type of Object.keys(this.connectionsBySourceNode[sourceNode])) {
                for (sourceIndex of Object.keys(this.connectionsBySourceNode[sourceNode][type])) {
                    for (connectionIndex of Object.keys(this.connectionsBySourceNode[sourceNode][type][parseInt(sourceIndex, 10)])) {
                        connectionData = this.connectionsBySourceNode[sourceNode][type][parseInt(sourceIndex, 10)][parseInt(connectionIndex, 10)];
                        if (connectionData.node === currentName) {
                            connectionData.node = newName;
                        }
                    }
                }
            }
        }
        this.connectionsByDestinationNode = this.__getConnectionsByDestination(this.connectionsBySourceNode);
    }
    getHighestNode(nodeName, type = 'main', nodeConnectionIndex, checkedNodes) {
        const currentHighest = [];
        if (this.nodes[nodeName].disabled === false) {
            currentHighest.push(nodeName);
        }
        if (!this.connectionsByDestinationNode.hasOwnProperty(nodeName)) {
            return currentHighest;
        }
        if (!this.connectionsByDestinationNode[nodeName].hasOwnProperty(type)) {
            return currentHighest;
        }
        if (checkedNodes === undefined) {
            checkedNodes = [];
        }
        if (checkedNodes.includes(nodeName)) {
            return [];
        }
        checkedNodes.push(nodeName);
        const returnNodes = [];
        let addNodes;
        let connectionsByIndex;
        for (let connectionIndex = 0; connectionIndex < this.connectionsByDestinationNode[nodeName][type].length; connectionIndex++) {
            if (nodeConnectionIndex !== undefined && nodeConnectionIndex !== connectionIndex) {
                continue;
            }
            connectionsByIndex = this.connectionsByDestinationNode[nodeName][type][connectionIndex];
            connectionsByIndex.forEach((connection) => {
                if (checkedNodes.includes(connection.node)) {
                    return;
                }
                addNodes = this.getHighestNode(connection.node, type, undefined, checkedNodes);
                if (addNodes.length === 0) {
                    if (this.nodes[connection.node].disabled !== true) {
                        addNodes = [connection.node];
                    }
                }
                addNodes.forEach((name) => {
                    if (returnNodes.indexOf(name) === -1 && !checkedNodes.includes(name)) {
                        returnNodes.push(name);
                    }
                });
            });
        }
        return returnNodes;
    }
    getParentNodes(nodeName, type = 'main', depth = -1, checkedNodes) {
        depth = depth === -1 ? -1 : depth;
        const newDepth = depth === -1 ? depth : depth - 1;
        if (depth === 0) {
            return [];
        }
        if (!this.connectionsByDestinationNode.hasOwnProperty(nodeName)) {
            return [];
        }
        if (!this.connectionsByDestinationNode[nodeName].hasOwnProperty(type)) {
            return [];
        }
        if (checkedNodes === undefined) {
            checkedNodes = [];
        }
        if (checkedNodes.includes(nodeName)) {
            return [];
        }
        checkedNodes.push(nodeName);
        const returnNodes = [];
        let addNodes;
        let nodeIndex;
        let i;
        let parentNodeName;
        this.connectionsByDestinationNode[nodeName][type].forEach((connectionsByIndex) => {
            connectionsByIndex.forEach((connection) => {
                if (checkedNodes.includes(connection.node)) {
                    return;
                }
                returnNodes.unshift(connection.node);
                addNodes = this.getParentNodes(connection.node, type, newDepth, checkedNodes);
                for (i = addNodes.length; i--; i > 0) {
                    parentNodeName = addNodes[i];
                    nodeIndex = returnNodes.indexOf(parentNodeName);
                    if (nodeIndex !== -1) {
                        returnNodes.splice(nodeIndex, 1);
                    }
                    returnNodes.unshift(parentNodeName);
                }
            });
        });
        return returnNodes;
    }
    getWebhookParameterValue(node, webhookDescription, parameterName, defaultValue) {
        const parameterValue = webhookDescription[parameterName];
        if (parameterValue === undefined) {
            return defaultValue;
        }
        const runIndex = 0;
        const itemIndex = 0;
        const connectionInputData = [];
        const runData = {
            resultData: {
                runData: {},
            }
        };
        return this.getParameterValue(parameterValue, runData, runIndex, itemIndex, node.name, connectionInputData);
    }
    getStartNodes(destinationNode) {
        const returnData = [];
        if (destinationNode) {
            const nodeNames = this.getHighestNode(destinationNode);
            if (nodeNames.length === 0) {
                nodeNames.push(destinationNode);
            }
            nodeNames.forEach((nodeName) => {
                returnData.push(this.nodes[nodeName]);
            });
        }
        else {
            let nodeType;
            for (const nodeName of Object.keys(this.nodes)) {
                nodeType = this.nodeTypes.getByName(this.nodes[nodeName].type);
                if (nodeType !== undefined && nodeType.description.inputs.length === 0 && this.nodes[nodeName].disabled !== true) {
                    returnData.push(this.nodes[nodeName]);
                }
            }
        }
        return returnData;
    }
    getParameterValue(parameterValue, runExecutionData, runIndex, itemIndex, activeNodeName, connectionInputData, returnObjectAsString = false) {
        const isComplexParameter = (value) => {
            return typeof value === 'object';
        };
        const resolveParameterValue = (value) => {
            if (isComplexParameter(value)) {
                return this.getParameterValue(value, runExecutionData, runIndex, itemIndex, activeNodeName, connectionInputData, returnObjectAsString);
            }
            else {
                return this.resolveSimpleParameterValue(value, runExecutionData, runIndex, itemIndex, activeNodeName, connectionInputData, returnObjectAsString);
            }
        };
        if (!isComplexParameter(parameterValue)) {
            return this.resolveSimpleParameterValue(parameterValue, runExecutionData, runIndex, itemIndex, activeNodeName, connectionInputData, returnObjectAsString);
        }
        if (Array.isArray(parameterValue)) {
            const returnData = [];
            for (const item of parameterValue) {
                returnData.push(resolveParameterValue(item));
            }
            if (returnObjectAsString === true && typeof returnData === 'object') {
                return this.convertObjectValueToString(returnData);
            }
            return returnData;
        }
        else {
            const returnData = {};
            for (const key of Object.keys(parameterValue)) {
                returnData[key] = resolveParameterValue(parameterValue[key]);
            }
            if (returnObjectAsString === true && typeof returnData === 'object') {
                return this.convertObjectValueToString(returnData);
            }
            return returnData;
        }
    }
    resolveSimpleParameterValue(parameterValue, runExecutionData, runIndex, itemIndex, activeNodeName, connectionInputData, returnObjectAsString = false) {
        if (typeof parameterValue !== 'string' || parameterValue.charAt(0) !== '=') {
            return parameterValue;
        }
        parameterValue = parameterValue.substr(1);
        const dataProxy = new _1.WorkflowDataProxy(this, runExecutionData, runIndex, itemIndex, activeNodeName, connectionInputData);
        try {
            const returnValue = tmpl.tmpl(parameterValue, dataProxy.getDataProxy());
            if (typeof returnValue === 'object' && Object.keys(returnValue).length === 0) {
                throw new Error('Expression is not valid.');
            }
            if (returnObjectAsString === true && typeof returnValue === 'object') {
                return this.convertObjectValueToString(returnValue);
            }
            return returnValue;
        }
        catch (e) {
            throw new Error('Expression is not valid.');
        }
    }
    async runNodeHooks(hookName, webhookData, nodeExecuteFunctions, mode) {
        const node = this.getNode(webhookData.node);
        const nodeType = this.nodeTypes.getByName(node.type);
        if (nodeType.description.hooks === undefined) {
            return;
        }
        if (nodeType.description.hooks[hookName] === undefined) {
            return;
        }
        if (nodeType.hooks === undefined && nodeType.description.hooks[hookName].length !== 0) {
            throw new Error('There are hooks defined to run but are not implemented.');
        }
        for (const hookDescription of nodeType.description.hooks[hookName]) {
            const thisArgs = nodeExecuteFunctions.getExecuteHookFunctions(this, node, webhookData.workflowExecuteAdditionalData, mode);
            await nodeType.hooks[hookDescription.method].call(thisArgs);
        }
    }
    async runWebhookMethod(method, webhookData, nodeExecuteFunctions, mode, isTest) {
        const node = this.getNode(webhookData.node);
        const nodeType = this.nodeTypes.getByName(node.type);
        if (nodeType.webhookMethods === undefined) {
            return;
        }
        if (nodeType.webhookMethods[webhookData.webhookDescription.name] === undefined) {
            return;
        }
        if (nodeType.webhookMethods[webhookData.webhookDescription.name][method] === undefined) {
            return;
        }
        const thisArgs = nodeExecuteFunctions.getExecuteHookFunctions(this, node, webhookData.workflowExecuteAdditionalData, mode, isTest);
        return nodeType.webhookMethods[webhookData.webhookDescription.name][method].call(thisArgs);
    }
    async runTrigger(node, nodeExecuteFunctions, additionalData, mode) {
        const thisArgs = nodeExecuteFunctions.getExecuteTriggerFunctions(this, node, additionalData, mode);
        const nodeType = this.nodeTypes.getByName(node.type);
        if (nodeType === undefined) {
            throw new Error(`The node type "${node.type}" of node "${node.name}" is not known.`);
        }
        if (!nodeType.trigger) {
            throw new Error(`The node type "${node.type}" of node "${node.name}" does not have a trigger function defined.`);
        }
        if (mode === 'manual') {
            const triggerReponse = await nodeType.trigger.call(thisArgs);
            triggerReponse.manualTriggerResponse = new Promise((resolve) => {
                thisArgs.emit = ((resolve) => (data) => {
                    resolve(data);
                })(resolve);
            });
            return triggerReponse;
        }
        else {
            return nodeType.trigger.call(thisArgs);
        }
    }
    async runWebhook(node, additionalData, nodeExecuteFunctions, mode) {
        const nodeType = this.nodeTypes.getByName(node.type);
        if (nodeType === undefined) {
            throw new Error(`The type of the webhook node "${node.name}" is not known.`);
        }
        else if (nodeType.webhook === undefined) {
            throw new Error(`The node "${node.name}" does not have any webhooks defined.`);
        }
        const thisArgs = nodeExecuteFunctions.getExecuteWebhookFunctions(this, node, additionalData, mode);
        return nodeType.webhook.call(thisArgs);
    }
    async runNode(node, inputData, runExecutionData, runIndex, additionalData, nodeExecuteFunctions, mode) {
        if (node.disabled === true) {
            if (inputData.hasOwnProperty('main') && inputData.main.length > 0) {
                if (inputData.main[0] === null) {
                    return null;
                }
                return [inputData.main[0]];
            }
            return null;
        }
        const nodeType = this.nodeTypes.getByName(node.type);
        if (nodeType === undefined) {
            throw new Error(`Node type "${node.type}" is not known so can not run it!`);
        }
        let connectionInputData = [];
        if (inputData.hasOwnProperty('main') && inputData.main.length > 0) {
            connectionInputData = inputData.main[0];
        }
        if (connectionInputData.length === 0) {
            return null;
        }
        if (nodeType.executeSingle) {
            const returnPromises = [];
            for (let itemIndex = 0; itemIndex < connectionInputData.length; itemIndex++) {
                const thisArgs = nodeExecuteFunctions.getExecuteSingleFunctions(this, runExecutionData, runIndex, connectionInputData, inputData, node, itemIndex, additionalData, mode);
                returnPromises.push(nodeType.executeSingle.call(thisArgs));
            }
            if (returnPromises.length === 0) {
                return null;
            }
            let promiseResults;
            try {
                promiseResults = await Promise.all(returnPromises);
            }
            catch (error) {
                return Promise.reject(error);
            }
            if (promiseResults) {
                return [promiseResults];
            }
        }
        else if (nodeType.execute) {
            const thisArgs = nodeExecuteFunctions.getExecuteFunctions(this, runExecutionData, runIndex, connectionInputData, inputData, node, additionalData, mode);
            return nodeType.execute.call(thisArgs);
        }
        else if (nodeType.trigger) {
            if (mode === 'manual') {
                const triggerResponse = await this.runTrigger(node, nodeExecuteFunctions, additionalData, mode);
                if (triggerResponse === undefined) {
                    return null;
                }
                if (triggerResponse.manualTriggerFunction !== undefined) {
                    await triggerResponse.manualTriggerFunction();
                }
                const response = await triggerResponse.manualTriggerResponse;
                if (triggerResponse.closeFunction) {
                    await triggerResponse.closeFunction();
                }
                if (response.length === 0) {
                    return null;
                }
                return response;
            }
            else {
                return _1.NodeHelpers.prepareOutputData(connectionInputData);
            }
        }
        else if (nodeType.webhook) {
            return _1.NodeHelpers.prepareOutputData(connectionInputData);
        }
        return null;
    }
}
exports.Workflow = Workflow;
//# sourceMappingURL=Workflow.js.map