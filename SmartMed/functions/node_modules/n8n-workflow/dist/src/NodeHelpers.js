"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
function displayParameter(nodeValues, parameter, nodeValuesRoot) {
    if (!parameter.displayOptions) {
        return true;
    }
    nodeValuesRoot = nodeValuesRoot || nodeValues;
    let value;
    if (parameter.displayOptions.show) {
        for (const propertyName of Object.keys(parameter.displayOptions.show)) {
            if (propertyName.charAt(0) === '/') {
                value = nodeValuesRoot[propertyName.slice(1)];
            }
            else {
                value = nodeValues[propertyName];
            }
            if (value === undefined || !parameter.displayOptions.show[propertyName].includes(value)) {
                return false;
            }
        }
        return true;
    }
    if (parameter.displayOptions.hide) {
        for (const propertyName of Object.keys(parameter.displayOptions.hide)) {
            if (propertyName.charAt(0) === '/') {
                value = nodeValuesRoot[propertyName.slice(1)];
            }
            else {
                value = nodeValues[propertyName];
            }
            if (value !== undefined && parameter.displayOptions.hide[propertyName].includes(value)) {
                return false;
            }
        }
    }
    return true;
}
exports.displayParameter = displayParameter;
function displayParameterPath(nodeValues, parameter, path) {
    let resolvedNodeValues = nodeValues;
    if (path !== '') {
        resolvedNodeValues = lodash_1.get(nodeValues, path);
    }
    let nodeValuesRoot = nodeValues;
    if (path && path.split('.').indexOf('parameters') === 0) {
        nodeValuesRoot = lodash_1.get(nodeValues, 'parameters');
    }
    return displayParameter(resolvedNodeValues, parameter, nodeValuesRoot);
}
exports.displayParameterPath = displayParameterPath;
function getContext(runExecutionData, type, node) {
    if (runExecutionData.executionData === undefined) {
        throw new Error('The "executionData" is not initialized!');
    }
    let key;
    if (type === 'flow') {
        key = 'flow';
    }
    else if (type === 'node') {
        if (node === undefined) {
            throw new Error(`The request data of context type "node" the node parameter has to be set!`);
        }
        key = `node:${node.name}`;
    }
    else {
        throw new Error(`The context type "${type}" is not know. Only "flow" and node" are supported!`);
    }
    if (runExecutionData.executionData.contextData[key] === undefined) {
        runExecutionData.executionData.contextData[key] = {};
    }
    return runExecutionData.executionData.contextData[key];
}
exports.getContext = getContext;
function getNodeParameters(nodePropertiesArray, nodeValues, returnDefaults, returnNoneDisplayed, onlySimpleTypes = false, dataIsResolved = false, nodeValuesRoot, parentType) {
    const nodeParameters = {};
    let nodeValuesDisplayCheck = nodeValues;
    if (dataIsResolved !== true && returnNoneDisplayed === false) {
        nodeValuesDisplayCheck = getNodeParameters(nodePropertiesArray, nodeValues, true, true, true, true, nodeValuesRoot, parentType);
    }
    nodeValuesRoot = nodeValuesRoot || nodeValuesDisplayCheck;
    for (const nodeProperties of nodePropertiesArray) {
        if (nodeValues[nodeProperties.name] === undefined && (returnDefaults === false || parentType === 'collection')) {
            continue;
        }
        if (returnNoneDisplayed === false && !displayParameter(nodeValuesDisplayCheck, nodeProperties, nodeValuesRoot)) {
            if (returnNoneDisplayed === false) {
                continue;
            }
            if (returnDefaults === false) {
                continue;
            }
        }
        if (!['collection', 'fixedCollection'].includes(nodeProperties.type)) {
            if (returnDefaults === true) {
                if (['boolean', 'number'].includes(nodeProperties.type)) {
                    nodeParameters[nodeProperties.name] = nodeValues[nodeProperties.name] !== undefined ? nodeValues[nodeProperties.name] : nodeProperties.default;
                }
                else {
                    nodeParameters[nodeProperties.name] = nodeValues[nodeProperties.name] || nodeProperties.default;
                }
            }
            else if (nodeValues[nodeProperties.name] !== nodeProperties.default || (nodeValues[nodeProperties.name] !== undefined && parentType === 'collection')) {
                nodeParameters[nodeProperties.name] = nodeValues[nodeProperties.name];
                continue;
            }
        }
        if (onlySimpleTypes === true) {
            continue;
        }
        let tempValue;
        if (nodeProperties.type === 'collection') {
            if (nodeProperties.typeOptions !== undefined && nodeProperties.typeOptions.multipleValues === true) {
                if (nodeValues[nodeProperties.name] !== undefined) {
                    nodeParameters[nodeProperties.name] = nodeValues[nodeProperties.name];
                }
                else if (returnDefaults === true) {
                    nodeParameters[nodeProperties.name] = [];
                }
            }
            else {
                if (nodeValues[nodeProperties.name] !== undefined) {
                    const tempNodeParameters = getNodeParameters(nodeProperties.options, nodeValues[nodeProperties.name], returnDefaults, returnNoneDisplayed, false, false, nodeValuesRoot, nodeProperties.type);
                    if (tempNodeParameters !== null) {
                        nodeParameters[nodeProperties.name] = tempNodeParameters;
                    }
                }
                else if (returnDefaults === true) {
                    nodeParameters[nodeProperties.name] = JSON.parse(JSON.stringify(nodeProperties.default));
                }
            }
        }
        else if (nodeProperties.type === 'fixedCollection') {
            const collectionValues = {};
            let tempNodeParameters;
            let tempNodePropertiesArray;
            let nodePropertyOptions;
            let propertyValues = nodeValues[nodeProperties.name];
            if (returnDefaults === true) {
                if (propertyValues === undefined) {
                    propertyValues = JSON.parse(JSON.stringify(nodeProperties.default));
                }
            }
            for (const itemName of Object.keys(propertyValues)) {
                if (nodeProperties.typeOptions !== undefined && nodeProperties.typeOptions.multipleValues === true) {
                    const tempArrayValue = [];
                    for (const nodeValue of propertyValues[itemName]) {
                        nodePropertyOptions = nodeProperties.options.find((nodePropertyOptions) => nodePropertyOptions.name === itemName);
                        if (nodePropertyOptions === undefined) {
                            throw new Error(`Could not find property option "${itemName}" for "${nodeProperties.name}"`);
                        }
                        tempNodePropertiesArray = nodePropertyOptions.values;
                        tempValue = getNodeParameters(tempNodePropertiesArray, nodeValue, returnDefaults, returnNoneDisplayed, false, false, nodeValuesRoot, nodeProperties.type);
                        if (tempValue !== null) {
                            tempArrayValue.push(tempValue);
                        }
                    }
                    collectionValues[itemName] = tempArrayValue;
                }
                else {
                    tempNodeParameters = {};
                    const nodePropertyOptions = nodeProperties.options.find((data) => data.name === itemName);
                    if (nodePropertyOptions !== undefined) {
                        tempNodePropertiesArray = nodePropertyOptions.values;
                        tempValue = getNodeParameters(tempNodePropertiesArray, nodeValues[nodeProperties.name][itemName], returnDefaults, returnNoneDisplayed, false, false, nodeValuesRoot, nodeProperties.type);
                        if (tempValue !== null) {
                            Object.assign(tempNodeParameters, tempValue);
                        }
                    }
                    if (Object.keys(tempNodeParameters).length !== 0) {
                        collectionValues[itemName] = tempNodeParameters;
                    }
                }
            }
            if (Object.keys(collectionValues).length !== 0 || returnDefaults === true) {
                if (returnDefaults === true) {
                    if (collectionValues === undefined) {
                        nodeParameters[nodeProperties.name] = JSON.parse(JSON.stringify(nodeProperties.default));
                    }
                    else {
                        nodeParameters[nodeProperties.name] = collectionValues;
                    }
                }
                else if (collectionValues !== nodeProperties.default) {
                    nodeParameters[nodeProperties.name] = collectionValues;
                }
            }
        }
    }
    return nodeParameters;
}
exports.getNodeParameters = getNodeParameters;
async function prepareOutputData(outputData, outputIndex = 0) {
    const returnData = [];
    for (let i = 0; i < outputIndex; i++) {
        returnData.push([]);
    }
    returnData.push(outputData);
    return returnData;
}
exports.prepareOutputData = prepareOutputData;
function getNodeWebhooks(workflow, node, additionalData) {
    if (node.disabled === true) {
        return [];
    }
    if (workflow.id === undefined) {
        return [];
    }
    const nodeType = workflow.nodeTypes.getByName(node.type);
    if (nodeType.description.webhooks === undefined) {
        return [];
    }
    const returnData = [];
    for (const webhookDescription of nodeType.description.webhooks) {
        let nodeWebhookPath = workflow.getWebhookParameterValue(node, webhookDescription, 'path', 'GET');
        if (nodeWebhookPath === undefined) {
            console.error(`No webhook path could be found for node "${node.name}" in workflow "${workflow.id}".`);
            continue;
        }
        if (nodeWebhookPath.charAt(0) === '/') {
            nodeWebhookPath = nodeWebhookPath.slice(1);
        }
        const path = getNodeWebhookPath(workflow.id, node, nodeWebhookPath);
        const httpMethod = workflow.getWebhookParameterValue(node, webhookDescription, 'httpMethod', 'GET');
        if (httpMethod === undefined) {
            console.error(`The webhook "${path}" for node "${node.name}" in workflow "${workflow.id}" could not be added because the httpMethod is not defined.`);
            continue;
        }
        returnData.push({
            httpMethod: httpMethod,
            node: node.name,
            path,
            webhookDescription,
            workflow,
            workflowExecuteAdditionalData: additionalData,
        });
    }
    return returnData;
}
exports.getNodeWebhooks = getNodeWebhooks;
function getNodeWebhookPath(workflowId, node, path) {
    return `${workflowId}/${encodeURIComponent(node.name.toLowerCase())}/${path}`;
}
exports.getNodeWebhookPath = getNodeWebhookPath;
function getNodeWebhookUrl(baseUrl, workflowId, node, path) {
    return `${baseUrl}/${getNodeWebhookPath(workflowId, node, path)}`;
}
exports.getNodeWebhookUrl = getNodeWebhookUrl;
function getNodeParametersIssues(nodePropertiesArray, node) {
    const foundIssues = {};
    let propertyIssues;
    for (const nodeProperty of nodePropertiesArray) {
        propertyIssues = getParameterIssues(nodeProperty, node.parameters, '');
        mergeIssues(foundIssues, propertyIssues);
    }
    if (Object.keys(foundIssues).length === 0) {
        return null;
    }
    return foundIssues;
}
exports.getNodeParametersIssues = getNodeParametersIssues;
function nodeIssuesToString(issues, node) {
    const nodeIssues = [];
    if (issues.execution !== undefined) {
        nodeIssues.push(`Execution Error.`);
    }
    const objectProperties = [
        'parameters',
        'credentials',
    ];
    let issueText, parameterName;
    for (const propertyName of objectProperties) {
        if (issues[propertyName] !== undefined) {
            for (parameterName of Object.keys(issues[propertyName])) {
                for (issueText of issues[propertyName][parameterName]) {
                    nodeIssues.push(issueText);
                }
            }
        }
    }
    if (issues.typeUnknown !== undefined) {
        if (node !== undefined) {
            nodeIssues.push(`Node Type "${node.type}" is not known.`);
        }
        else {
            nodeIssues.push(`Node Type is not known.`);
        }
    }
    return nodeIssues;
}
exports.nodeIssuesToString = nodeIssuesToString;
function addToIssuesIfMissing(foundIssues, nodeProperties, value) {
    if ((nodeProperties.type === 'string' && (value === '' || value === undefined)) ||
        (nodeProperties.type === 'multiOptions' && Array.isArray(value) && value.length === 0) ||
        (nodeProperties.type === 'dateTime' && value === undefined)) {
        if (foundIssues.parameters === undefined) {
            foundIssues.parameters = {};
        }
        if (foundIssues.parameters[nodeProperties.name] === undefined) {
            foundIssues.parameters[nodeProperties.name] = [];
        }
        foundIssues.parameters[nodeProperties.name].push(`Parameter "${nodeProperties.displayName}" is required.`);
    }
}
exports.addToIssuesIfMissing = addToIssuesIfMissing;
function getParameterValueByPath(nodeValues, parameterName, path) {
    return lodash_1.get(nodeValues, path ? path + '.' + parameterName : parameterName);
}
exports.getParameterValueByPath = getParameterValueByPath;
function getParameterIssues(nodeProperties, nodeValues, path) {
    const foundIssues = {};
    let value;
    if (nodeProperties.required === true) {
        if (displayParameterPath(nodeValues, nodeProperties, path)) {
            value = getParameterValueByPath(nodeValues, nodeProperties.name, path);
            if (nodeProperties.typeOptions !== undefined && nodeProperties.typeOptions.multipleValues !== undefined) {
                if (Array.isArray(value)) {
                    for (const singleValue of value) {
                        addToIssuesIfMissing(foundIssues, nodeProperties, singleValue);
                    }
                }
            }
            else {
                addToIssuesIfMissing(foundIssues, nodeProperties, value);
            }
        }
    }
    if (nodeProperties.options === undefined) {
        return foundIssues;
    }
    let basePath = path ? `${path}.` : '';
    const checkChildNodeProperties = [];
    if (nodeProperties.type === 'collection') {
        for (const option of nodeProperties.options) {
            checkChildNodeProperties.push({
                basePath,
                data: option,
            });
        }
    }
    else if (nodeProperties.type === 'fixedCollection') {
        basePath = basePath ? `${basePath}.` : '' + nodeProperties.name + '.';
        let propertyOptions;
        for (propertyOptions of nodeProperties.options) {
            value = getParameterValueByPath(nodeValues, propertyOptions.name, basePath.slice(0, -1));
            if (value === undefined) {
                continue;
            }
            if (nodeProperties.typeOptions !== undefined && nodeProperties.typeOptions.multipleValues !== undefined) {
                if (Array.isArray(value)) {
                    for (let i = 0; i < value.length; i++) {
                        for (const option of propertyOptions.values) {
                            checkChildNodeProperties.push({
                                basePath: `${basePath}${propertyOptions.name}[${i}]`,
                                data: option,
                            });
                        }
                    }
                }
            }
            else {
                for (const option of propertyOptions.values) {
                    checkChildNodeProperties.push({
                        basePath: basePath + propertyOptions.name,
                        data: option,
                    });
                }
            }
        }
    }
    else {
        return foundIssues;
    }
    let propertyIssues;
    for (const optionData of checkChildNodeProperties) {
        propertyIssues = getParameterIssues(optionData.data, nodeValues, optionData.basePath);
        mergeIssues(foundIssues, propertyIssues);
    }
    return foundIssues;
}
exports.getParameterIssues = getParameterIssues;
function mergeIssues(destination, source) {
    if (source === null) {
        return;
    }
    if (source.execution === true) {
        destination.execution = true;
    }
    const objectProperties = [
        'parameters',
        'credentials',
    ];
    let destinationProperty;
    for (const propertyName of objectProperties) {
        if (source[propertyName] !== undefined) {
            if (destination[propertyName] === undefined) {
                destination[propertyName] = {};
            }
            let parameterName;
            for (parameterName of Object.keys(source[propertyName])) {
                destinationProperty = destination[propertyName];
                if (destinationProperty[parameterName] === undefined) {
                    destinationProperty[parameterName] = [];
                }
                destinationProperty[parameterName].push.apply(destinationProperty[parameterName], source[propertyName][parameterName]);
            }
        }
    }
    if (source.typeUnknown === true) {
        destination.typeUnknown = true;
    }
}
exports.mergeIssues = mergeIssues;
//# sourceMappingURL=NodeHelpers.js.map